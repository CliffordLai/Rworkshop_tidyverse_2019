---
title: "Data Transfromation"
author: "Your name"
date: "`r Sys.Date()`"
output: 
  html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE)
```

## Load tidyverse

```{r cars}
library(tidyverse)
```

## Pipe operator

```{r}
c(1,2,9,4,5,7,8) %>% mean()  
mean(c(1,2,9,4,5,7,8)) #equivalent
```

## Iris data

```{r}
# load data
data(iris) 
iris %>% View()

iris # lengthy output
iris %>% as_tibble() #tibble, simple Data Frames, 

iris %>%
  as_tibble() %>%
  print(n=15)

# Object class
iris %>% class()
iris %>%
  as_tibble() %>%
  class()

# Update data
iris <- iris %>% as_tibble() 
iris

# View data
iris %>% glimpse()

str(iris)
```


## Subset by columns with `select`

tibble in, tibble out

```{r}
?select
iris %>% names()

# Select the first two variables
#by name
#by index

# Select all but one variable 


# Select columns of which names contain "Length"


# Only want numerical variables


# A problem occur if one directly apply a function to tibble


# Extract a column as a vector with pull


# Or use summarize


# To save the result, you need to assign it to a (new) object


```


## Subset by rows with `filter`

```{r}
?filter

# Keep rows by one condition


# Keep rows by two conditions


# Remove rows with missing Sepal.Length though there is no missing value


# Remove rows with missing values thought there is no


# Find the average of Petal.Length for the Species of virginica


```


## Sort data with `arrange`

```{r}
?arrange

# sort rows by Sepal.Length

# descending order

# sort by the orders of multiple variables
```


## Create new variables with `mutate`

```{r}
?mutate

# create Sepal.LW=Sepal.Length/Sepal.Width
# create Sepal.Area=Sepal.Length*Sepal.Width
iris$Sepal.diff <- iris$Sepal.Length-iris$Sepal.Width




# Overwrite the old variable

# The order of new variables matters!

```

## Compute summary statistics for each column with `summarise_all`

```{r}
?summarise_all

# Different ways of computing the column means
# 1: colMeans
# 2: apply
# 3: summarise_all

# Count the missing values
# Use ~(sum(is.na(.))/n())
# It is equivalent to
# function(x){sum(is.na(x)/length(x))}
# ~ is called Lambda/Anonymous function



# Gather columns into key-value pairs (transpose data frame)


# Count the unique values for each column
# use n_distinct

```


## Compute summary statistics with `summarize`

```{r}
?summarise

# compute and return a tibble
# m1=mean(Sepal.Length)
# v1=var(Sepal.Length)

```

## Compute summary statistics for each group with `summarize` and `group_by`

Notice that the group attribute will be resolved after a summary function is applied.

```{r}
# The base R way (aggregate) of computing summation of each variable within each group


# Add the group attribute by group_by so that 
# tidyverse knows a groupwise summary statistics should be computed

  
# Force a data.frame() output  
```

## Rowise group with 'rowwise'

Sometimes, we may need to perform complex operation that mutate is behaving strangely with.
For example, if one wants to find 
the maximum between sepal (petal) length and sepal (petal) width for each sample, 
then we can obtain the result by

```{r}
# rowwise()

# Find the max(Sepal.Length, Sepal.Width)
# and max(Petal.Length, Petal.Width).

# Notice the group attribute still exists
# Use ungroup() to resolve it




```


## Group by multiple variables

```{r}
iris2 <- iris %>%   
  mutate(longSepal=ifelse(Sepal.Length>5.8,"Y","N"))

# group attribute has two layers Species,longSepal

# mutate does not change group index


# One summarize unfold one group layer

```


## Join the summary results back to the data with `left_join`

```{r}
# 1. Summary the mean for each column by Species
# 2. Rename columns

# Traditional way of renaming columns
#names(irisSummary) <- c("Species", "meanSL", "meanSW", "meanPL", "meanPW")

# Join the information back to the original data by matching Species

```

## Use `left_join` or `right_join` to check the overlap between two data sets

```{r}
# Replace matched patterns in a string.
?str_replace

str_replace(c("abaab","b","cb"), "b", "c")

str_replace_all(c("abaab","b","cb"), "b", "c")

str_replace_all(c("abaab","b","cb"), "[ab]", "c")

# set the working directory
setwd("C:/Users/Hao/Dropbox/newtermphd/Term12/Rworkshop_tidyverse_2019/example/")

# read_csv
morning <- read_csv("IntermediateR_2019Nov_anonymous.csv",skip = 2)
afternoon <- read_csv("DataManipulation_2019Nov_anonymous.csv",skip = 2)

morning
afternoon

morning %>% nrow()
afternoon %>% nrow()

# What is the difference?
morning %>% 
  left_join(afternoon, by = "Email") %>% 
  summarise(numMatch = sum(!is.na(`Last Name.y`)))

afternoon %>% 
  left_join(morning, by = "Email") %>% 
  summarise(numMatch = sum(!is.na(`Last Name.y`)))


sum(morning$Email %in% afternoon$Email)
sum(afternoon$Email %in% morning$Email)

# write_csv, na option

```



